---
rip: 0
title: An RIP-7560 transactions bundle subtype
description: An RIP-7560 transaction subtype that allows specifying a set of AA transactions that can be atomically validated together
author: Vitalik Buterin (@vbuterin), Yoav Weiss (@yoavw), Alex Forshtat (@forshtat), Dror Tirosh (@drortirosh), Shahaf Nacson (@shahafn)
discussions-to: https://ethereum-magicians.org/t/rip-7560-native-account-abstraction/16664
status: Draft
type: Standards Track
category: Core
created: 2023-09-01
requires: 7560
---


## Abstract

This proposal provides block builders with a mechanism to isolate validation from execution for
a set of RIP-7560 transactions.
By doing so we simplify the task of filling a block gas space with RIP-7560 transactions and prevent potential
denial of service attacks against block builders.

On "single sequencer" Layer 2 chains that do not have a "transaction mempool" in a traditional sense,
this proposal provides no benefit compared to the original RIP-7560.
It is required for DoS mitigation on every chain that does rely on a public mempool for block building, however.

## Motivation

The `AA_TX_TYPE` transaction type that is defined in RIP-7560 completely separates transaction validity
on a protocol level from ECDSA signatures or any other protocol-defined rules, instead allowing account's EVM code
to determine a validity of a transaction.

This validation EVM code, however, may be affected by any observable state change within a block.
A block builder trying to include a set of `AA_TX_TYPE` transactions may face a challenge of finding a combination
that fits together without invalidating each other.

The block builder has to execute the entire body of one transaction before picking the next one.
Additionally, it is not feasible to apply any limitations on the transaction execution, while it is expected that
the validation code will be constrained by the block builder with a ruleset like ERC-7562.

This document proposes a mechanism for block builder to specify a set of `AA_TX_TYPE` transactions that are guaranteed
to fit together due to a fact that all of their validation frames are executed consecutively first,
before their respective execution frames.

## Specification

### Bundle header RIP-7560 transaction subtype

```
BUNDLE_HEADER_SUBTYPE = x
```

Instead, we propose to introduce an explicit "counter" transaction subtype.

The payload should be interpreted as:

```
0x04 || 0x01 || rlp([chainId, transactionCount])
```

Header transactions have a unique hash calculated as follows:

```
keccak256(AA_TX_TYPE || 0x01 || rlp(chainId, transactionCount, blockNumber, txIndex))
```

The `blockNumber` and `txIndex` parameters are added to the hash to achieve unique header transaction IDs.

The header transactions are only used to help execution clients determine how many of the `AA_TX_TYPE` transactions
belong to each individual bundle.

The block is not valid if a header transaction is located anywhere except before a set of `AA_TX_TYPE` transactions.

Header transactions do not affect blockchain state and do not cost any gas.

### Non-atomic validation and execution transaction subtype

```
BUNDLE_TRANSACTION_SUBTYPE = x
```

These transactions are completely identical to regular RIP-7560 transactions with the exceptions of being
composable into bundles.

It is important for the wallets to explicitly opt into this feature, as some Smart Contract Accounts
may be created in a way that relies on atomicity between validation and execution phases.

### All validation state changes apply before all execution ones

Filling a block with AA transactions must not be a challenge for the block builder.
However, if each transaction during its execution can alter any state that affects the validity of another transaction
in the mempool, the block builder will be forced to revalidate all transactions in the mempool after each inclusion.

We mitigate that by applying all changes in all the validation frames of a sequence of AA transactions first
and all execution frames apply immediately after that.

In theory, the validation frames can also invalidate each other, but we define ways to prevent that by applying
certain rules for the mempool transactions in ERC-7562.

A builder that chooses not to enforce the rules from ERC-7562 **must** take care to re-validate each transaction
against the mid-block state at the position where it is being included into a block.
Otherwise, the resulting block is likely to end up being invalid.

### Block structure diagram

Here is a visual representation of a block that contains multiple Account Abstraction Transactions.
The validation parts of AA transactions are executed as separate transactions,
but are not represented as separate transactions in the block data.

![](../assets/rip-7560/block_overview.png)
*The structure of a block containing multiple Native Account Abstraction Transactions*

### Validation state change virtual transactions

The validation frames of the AA_TX_TYPE transaction are represented as individual virtual transactions by the clients.
They are assigned their own sequential `transactionIndex`, and their `transactionHash` is defined as
(`AA_TX_TYPE transaction hash + 1`).

All block-related RPC methods, like `eth_getBlockByHash` and `eth_getBlockByNumber`, must include these virtual
transactions as part of the `transactions` field and include validation in the block transaction count.

All transaction-related RPC methods, like `eth_getTransactionByHash` and `eth_getTransactionReceipt`, must
accept the virtual transaction hash as input and return the details calculated as if the validation was a
separate transaction.

There is a number of behaviours that define transaction-wide effects in Ethereum.
This list includes, but is not limited to:

* Tracking `accessed_addresses`
* [EIP-1283](https://eips.ethereum.org/EIPS/eip-1283) Gas metering for SSTORE
* [EIP-1153](https://eips.ethereum.org/EIPS/eip-1153) Transient storage opcodes

Any such behaviour has separate effects in the "Validation Virtual Transaction" and "Execution Transaction".

Gas refunds are issued at the end of the entire transaction only.

### Unused gas penalty charge

```
UNUSED_GAS_PENALTY = 10
```

Transactions of type `BUNDLE_TRANSACTION_SUBTYPE` that reserve a lot of gas for themselves using `validationGasLimit`,
`paymasterGasLimit` and `callGasLimit` fields but do not use the reserved gas present a challenge for
block builders. This is especially demanding in case a gas used by a transaction can be significantly different
based on its position within a block, as such transactions may cause the block builder to iterate its algorithm
many times until a fully utilized block is discovered.

A penalty of `UNUSED_GAS_PENALTY` percent of the entire unused gas limit is charged from the
transaction `sender` or `paymaster`.

The total gas limit is calculated as `totalLimit = validationGasLimit + paymasterGasLimit + callGasLimit`.\
The `totalGasUsed` is calculated as a sum of all gas used during the transaction.\
The unused gas is calculated as `unusedGas = totalLimit - totalGasUsed`.

The effects of allowing transactions to specify unrestricted gas limits is shown on this diagram:
![](../assets/rip-7560/unused_gas_attack_overview.png)

## Rationale

### Using no-op transaction instead of adding a field to the block payload

While in this particular case there is no execution frame that needs to happen for
a `BUNDLE_HEADER_SUBTYPE` transaction, in other similar scenarios it is possible we
will require some execution for a header transaction.

For example, in (RIP-xxxx: Signature Aggregation)[todo] the header transaction contains
the execution of the aggregted signature verification code.

For consistency with potential future extensions to the RIP-7560 it seems reasonable to
introduce a no-op transaction subtype.

### Breaking up a transaction flow into non-atomic pieces

While changing the transaction flow is a departure from the norm for Ethereum transactions,
in practice this change is both very useful and not very complex.

The validation frames can be easily constrained with both gas limits and opcode bans.
The entire validation section of a correctly built bundle can therefore be protected from containing
mutually exclusive transactions.
The task of building a block becomes efficient and can be parallelized with no risk of DoS attacks.

For the EVM implementation the validation frames behave almost identical to a standalone transaction,
so there are no expected difficulties with implementing this proposal.

## Backwards Compatibility


## Security Considerations

### Attacks on validation-execution separation

Accounts in RIP-7560 are instructed not to expect the validation and execution to be atomic.
However, wallets may be implemented with an incorrect assumption that nothing can happen
between validation and execution phases, which is wrong.

The state that exists at the end of the validation frame may be observed or modified by unrelated contracts before
the execution frame begins.
`Sender` contracts must take great care in making sure their code does not make any false assumptions.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
